<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Matchstick Game - From "The Goal" by Eli Goldratt</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<style>
/* ===== Reset & Base ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: #0a1628;
  color: #e0e8f0;
  min-height: 100vh;
  overflow-x: hidden;
}

/* ===== Header ===== */
header {
  text-align: center;
  padding: 20px 20px 10px;
  background: linear-gradient(180deg, #0f1f3a 0%, #0a1628 100%);
  border-bottom: 1px solid #1a3050;
}
header h1 {
  font-size: 1.8rem;
  font-weight: 700;
  background: linear-gradient(135deg, #f0c040, #e8a020);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 4px;
}
header .subtitle {
  font-size: 0.85rem;
  color: #6088b0;
}

/* ===== Rules Toggle ===== */
.rules-toggle {
  text-align: center;
  margin: 8px 0;
}
.rules-toggle button {
  background: none;
  border: 1px solid #1a3050;
  color: #6088b0;
  padding: 4px 14px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.2s;
}
.rules-toggle button:hover { border-color: #f0c040; color: #f0c040; }
.rules-box {
  display: none;
  max-width: 700px;
  margin: 10px auto;
  background: #0f1f3a;
  border: 1px solid #1a3050;
  border-radius: 10px;
  padding: 16px 20px;
  text-align: left;
  font-size: 0.82rem;
  line-height: 1.6;
  color: #8aa8c8;
}
.rules-box.open { display: block; }
.rules-box strong { color: #f0c040; }
.rules-box .c-green { color: #30a060; font-weight: 600; }
.rules-box .c-gold { color: #f0c040; font-weight: 600; }
.rules-box .c-red { color: #d04040; font-weight: 600; }
.rules-box .c-orange { color: #e08030; font-weight: 600; }
.rules-box .c-purple { color: #a060d0; font-weight: 600; }
.rules-box .c-blue { color: #4090d0; font-weight: 600; }
.rules-box .metric-list { margin: 8px 0 4px 0; padding: 0; list-style: none; }
.rules-box .metric-list li { margin-bottom: 6px; padding-left: 8px; border-left: 3px solid #1a3050; }
.rules-box .metric-list li.m-green { border-left-color: #30a060; }
.rules-box .metric-list li.m-gold { border-left-color: #f0c040; }
.rules-box .metric-list li.m-red { border-left-color: #d04040; }
.rules-box .metric-list li.m-orange { border-left-color: #e08030; }
.rules-box .metric-list li.m-purple { border-left-color: #a060d0; }
.rules-box .metric-list li.m-blue { border-left-color: #4090d0; }

/* ===== Controls ===== */
.controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  padding: 14px 20px;
  flex-wrap: wrap;
}
.controls button {
  padding: 8px 22px;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}
.btn-roll {
  background: linear-gradient(135deg, #f0c040, #e8a020);
  color: #1a1a2e;
}
.btn-roll:hover { transform: scale(1.05); box-shadow: 0 0 16px rgba(240,192,64,0.4); }
.btn-roll:disabled { opacity: 0.4; cursor: default; transform: none; box-shadow: none; }
.btn-auto {
  background: linear-gradient(135deg, #30a060, #208040);
  color: #fff;
}
.btn-auto.playing {
  background: linear-gradient(135deg, #d04040, #b03030);
}
.btn-auto:hover { transform: scale(1.05); }
.btn-pause {
  background: linear-gradient(135deg, #4090d0, #3070b0);
  color: #fff;
}
.btn-pause:hover { transform: scale(1.05); }
.btn-pause:disabled { opacity: 0.3; cursor: default; transform: none; }
.btn-reset {
  background: #1a3050;
  color: #8aa8c8;
  border: 1px solid #2a4060;
}
.btn-reset:hover { background: #2a4060; color: #e0e8f0; }
.control-group {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.82rem;
  color: #6088b0;
}
.control-group select, .control-group input[type="range"] {
  background: #1a3050;
  color: #e0e8f0;
  border: 1px solid #2a4060;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 0.82rem;
}
.control-group input[type="range"] {
  width: 80px;
  accent-color: #f0c040;
}

/* ===== Production Line ===== */
.production-line {
  display: flex;
  align-items: flex-start;
  justify-content: center;
  gap: 8px;
  padding: 20px 16px;
  overflow-x: auto;
  position: relative;
}

/* Arrow between stations */
.arrow {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.4rem;
  color: #2a4060;
  padding-top: 58px;
  min-width: 18px;
  flex-shrink: 0;
}

/* ===== Matchbox (raw materials) ===== */
.matchbox {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 80px;
  flex-shrink: 0;
}
.matchbox-label {
  font-size: 0.7rem;
  color: #6088b0;
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.matchbox-body {
  width: 70px;
  height: 90px;
  background: linear-gradient(145deg, #8b4513, #a0522d, #8b4513);
  border-radius: 6px;
  border: 2px solid #654321;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.3);
}
.matchbox-body::before {
  content: '';
  position: absolute;
  top: 4px; left: 4px; right: 4px; bottom: 4px;
  border: 1px solid rgba(255,200,100,0.15);
  border-radius: 3px;
}
.matchbox-infinity {
  font-size: 2.2rem;
  color: #f0c040;
  text-shadow: 0 0 10px rgba(240,192,64,0.5);
}

/* ===== Station ===== */
.station {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 90px;
  flex-shrink: 0;
  transition: all 0.3s;
}
.station-name {
  font-size: 0.75rem;
  font-weight: 600;
  color: #8aa8c8;
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ===== Die ===== */
.die-container {
  margin-bottom: 8px;
  perspective: 300px;
}
.die {
  width: 48px;
  height: 48px;
  background: #f5f0e8;
  border-radius: 10px;
  display: grid;
  grid-template-rows: repeat(3, 1fr);
  grid-template-columns: repeat(3, 1fr);
  padding: 6px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.8);
  transition: transform 0.1s, box-shadow 0.3s;
  position: relative;
}
.die.rolling {
  animation: diceRoll 0.08s infinite alternate;
}
@keyframes diceRoll {
  0% { transform: rotateX(-8deg) rotateY(8deg) scale(1.05); }
  100% { transform: rotateX(8deg) rotateY(-8deg) scale(1.05); }
}
.die.starved {
  box-shadow: 0 0 14px rgba(220,60,60,0.7), 0 3px 8px rgba(0,0,0,0.4);
}
.die .dot {
  width: 9px;
  height: 9px;
  background: #2a2a3a;
  border-radius: 50%;
  align-self: center;
  justify-self: center;
  opacity: 0;
  transition: opacity 0.15s;
}
.die .dot.visible { opacity: 1; }

/* Dot positions for dice faces */
/* Dots indexed 0-8 in 3x3 grid:
   0 1 2
   3 4 5
   6 7 8
*/

/* ===== Bowl (SVG inline) ===== */
.bowl-area {
  position: relative;
  width: 80px;
  height: 55px;
  margin-bottom: 4px;
}
.bowl-svg {
  width: 80px;
  height: 55px;
}
.bowl-matches {
  position: absolute;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 1px;
  justify-content: center;
  flex-wrap: wrap;
  max-width: 60px;
}
.bowl-match {
  width: 3px;
  height: 14px;
  position: relative;
}
.bowl-match .stick {
  width: 3px;
  height: 10px;
  background: linear-gradient(90deg, #c8a050, #dab060, #c8a050);
  position: absolute;
  bottom: 0;
  border-radius: 0 0 1px 1px;
}
.bowl-match .head {
  width: 5px;
  height: 5px;
  background: radial-gradient(circle at 40% 35%, #ff6040, #cc3020);
  border-radius: 50% 50% 30% 30%;
  position: absolute;
  top: 0;
  left: -1px;
}
.bowl-count {
  font-size: 0.95rem;
  font-weight: 700;
  color: #f0c040;
  min-height: 1.2em;
}
.moved-info {
  font-size: 0.7rem;
  color: #50a060;
  min-height: 1em;
  margin-top: 2px;
}
.moved-info.starved-text { color: #d04040; }

/* Inventory bar under bowl */
.inventory-bar-track {
  width: 60px;
  height: 4px;
  background: #1a3050;
  border-radius: 2px;
  margin-top: 4px;
  overflow: hidden;
}
.inventory-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #30a060, #f0c040);
  border-radius: 2px;
  transition: width 0.4s, background 0.3s;
  min-width: 0;
}
.inventory-bar-fill.full {
  background: linear-gradient(90deg, #d04040, #e06040);
}

/* ===== Finished Goods Tray ===== */
.finished-tray {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 90px;
  flex-shrink: 0;
}
.finished-label {
  font-size: 0.7rem;
  color: #6088b0;
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.finished-body {
  width: 80px;
  min-height: 90px;
  background: #0f1f3a;
  border: 2px solid #30a060;
  border-radius: 8px;
  display: flex;
  flex-wrap: wrap;
  align-content: flex-end;
  justify-content: center;
  gap: 1px;
  padding: 6px;
  box-shadow: 0 0 12px rgba(48,160,96,0.2);
  transition: box-shadow 0.3s;
}
.finished-body.glow {
  box-shadow: 0 0 20px rgba(48,160,96,0.5);
}
.finished-count {
  font-size: 1.1rem;
  font-weight: 700;
  color: #30a060;
  margin-top: 6px;
}

/* Small match icon in finished tray */
.tiny-match {
  width: 2px;
  height: 10px;
  position: relative;
}
.tiny-match .stick {
  width: 2px;
  height: 7px;
  background: linear-gradient(90deg, #c8a050, #dab060);
  position: absolute;
  bottom: 0;
}
.tiny-match .head {
  width: 4px;
  height: 4px;
  background: radial-gradient(circle at 40% 35%, #ff6040, #cc3020);
  border-radius: 50%;
  position: absolute;
  top: 0;
  left: -1px;
}

/* ===== Flying Match Animation Overlay ===== */
.animation-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1000;
}
.flying-match {
  position: absolute;
  width: 4px;
  height: 18px;
  transition: none;
}
.flying-match .stick {
  width: 4px;
  height: 13px;
  background: linear-gradient(90deg, #c8a050, #dab060, #c8a050);
  position: absolute;
  bottom: 0;
  border-radius: 0 0 1px 1px;
}
.flying-match .head {
  width: 6px;
  height: 6px;
  background: radial-gradient(circle at 40% 35%, #ff6040, #cc3020);
  border-radius: 50% 50% 30% 30%;
  position: absolute;
  top: 0;
  left: -1px;
  box-shadow: 0 0 6px rgba(255,96,64,0.6);
}

/* ===== Stats Panel ===== */
.stats-rows {
  padding: 12px 20px 4px;
}
.stats-panel {
  display: flex;
  justify-content: center;
  gap: 14px;
  padding: 4px 0;
  flex-wrap: wrap;
}
.stat-card {
  text-align: center;
  background: #0f1f3a;
  border: 1px solid #1a3050;
  border-radius: 10px;
  padding: 10px 18px;
  min-width: 110px;
}
.stat-sub {
  font-size: 0.75rem;
  color: #506880;
  margin-top: 1px;
}
.stat-value {
  font-size: 1.4rem;
  font-weight: 700;
  color: #f0c040;
}
.stat-value.green { color: #30a060; }
.stat-value.red { color: #d04040; }
.stat-value.blue { color: #4090d0; }
.stat-value.yellow { color: #f0c040; }
.stat-value.orange { color: #e08030; }
.stat-value.purple { color: #a060d0; }
.stat-label {
  font-size: 0.7rem;
  color: #6088b0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 2px;
}

/* ===== Chart ===== */
.chart-container {
  max-width: 800px;
  margin: 10px auto 20px;
  padding: 0 20px;
}
.chart-wrapper {
  background: #0f1f3a;
  border: 1px solid #1a3050;
  border-radius: 12px;
  padding: 16px;
}

/* ===== Footer ===== */
footer {
  text-align: center;
  padding: 16px;
  font-size: 0.75rem;
  color: #3a5878;
  border-top: 1px solid #1a3050;
}
footer a { color: #6088b0; text-decoration: none; }
footer a:hover { color: #f0c040; }

/* ===== Nav Tabs ===== */
.nav-tabs { display: flex; justify-content: center; gap: 0; margin: 8px 0; }
.nav-tab {
  padding: 6px 20px; text-decoration: none; font-size: 0.85rem;
  color: #6088b0; border: 1px solid #1a3050; transition: all 0.2s;
}
.nav-tab:first-child { border-radius: 8px 0 0 8px; }
.nav-tab:last-child { border-radius: 0 8px 8px 0; }
.nav-tab.active { background: #f0c040; color: #1a1a2e; border-color: #f0c040; font-weight: 600; }
.nav-tab:not(.active):hover { color: #f0c040; border-color: #f0c040; }

/* ===== Bottleneck Highlighting ===== */
.station.bottleneck-stable .station-name { color: #e08030; text-shadow: 0 0 8px rgba(224,128,48,0.5); }
.station.bottleneck-moving .station-name { color: #d04040; animation: bottleneckPulse 1s infinite; }
@keyframes bottleneckPulse {
  0%, 100% { text-shadow: 0 0 4px rgba(208,64,64,0.3); }
  50% { text-shadow: 0 0 12px rgba(208,64,64,0.8); }
}

/* ===== Responsive ===== */
@media (max-width: 768px) {
  header h1 { font-size: 1.3rem; }
  .production-line { gap: 4px; padding: 12px 8px; }
  .station { min-width: 60px; }
  .die { width: 36px; height: 36px; padding: 4px; }
  .die .dot { width: 7px; height: 7px; }
  .bowl-area { width: 60px; height: 42px; }
  .bowl-svg { width: 60px; height: 42px; }
  .arrow { font-size: 1rem; padding-top: 40px; }
  .stats-panel { gap: 10px; }
  .stat-card { min-width: 80px; padding: 8px 10px; }
  .stat-value { font-size: 1.1rem; }
  .controls { gap: 8px; }
  .controls button { padding: 6px 14px; font-size: 0.8rem; }
}
</style>
</head>
<body>

<header>
  <h1>The Matchstick Game</h1>
  <div class="subtitle">From "The Goal" by Eli Goldratt &mdash; Chapter 14</div>
</header>

<div class="nav-tabs">
  <a href="index.html" class="nav-tab active">Observe</a>
  <a href="sandbox.html" class="nav-tab">Sandbox</a>
  <a href="game.html" class="nav-tab">Gam-ba</a>
</div>

<div class="rules-toggle">
  <button id="rulesBtn" onclick="toggleRules()">Show Rules</button>
</div>
<div class="rules-box" id="rulesBox">
  <strong>How it works:</strong> A line of workers (stations) passes matches from left to right. Each round, every worker rolls a die to determine how many matches they <em>can</em> move. But they can only move as many as are available in their bowl (max capacity: 4). Station 1 draws from unlimited raw materials.<br><br>
  <strong>Why buffer = 4?</strong> The average die roll is 3.5, so a buffer of 4 rounds up just slightly to give downstream stations a small cushion without over-compensating. A larger buffer would mask the effects of variability &mdash; exactly what we want to observe.<br><br>
  <strong>The insight:</strong> With a single die (average 3.5), you'd expect ~3.5 matches/round of throughput. But because <strong>statistical fluctuations</strong> combine with <strong>dependent events</strong> (each station depends on the previous), actual throughput drops well below the average. Negative fluctuations propagate downstream; positive fluctuations are wasted when there aren't enough matches to move.<br><br>
  <strong>Controls:</strong> Click <strong>Roll</strong> to advance one round, or use <strong>Auto Play</strong> to run continuously. Adjust the number of stations (3-10) to see how line length affects throughput loss.<br><br>

  <strong>Stats &amp; Chart Guide:</strong>
  <ul class="metric-list">
    <li class="m-gold"><span class="c-gold">Expected Throughput</span> (gold dashed line) &mdash; The expected throughput based on dice math: a six-sided die averages (1+2+3+4+5+6)&divide;6 = 3.5. If stations were independent (no starvation), output would average 3.5/round, so cumulative = 3.5 &times; rounds. The whole game exists to show why actual output falls below this line.</li>
    <li class="m-green"><span class="c-green">Cumulative Actual</span> (green line) &mdash; What throughput <em>actually</em> is: total matches that made it all the way through the line to finished goods. Watch this fall further and further behind the theoretical line.</li>
    <li class="m-green"><span class="c-green">Avg Throughput / Round</span> &mdash; Actual throughput divided by total rounds. In theory this should be 3.5, but you'll see it settle well below that.</li>
    <li class="m-red"><span class="c-red">Cumulative Lost Throughput</span> (red filled area) &mdash; The gap between theoretical and actual: how much throughput the system has lost overall. Actual + Lost = Theoretical. This red area fills the space between the gold and green lines, directly showing the cumulative cost of statistical fluctuations and dependent events.</li>
    <li class="m-orange"><span class="c-orange">WIP Inventory</span> (orange line, right axis) &mdash; Total work-in-progress: the sum of all matches sitting in bowls across the line. In a balanced system this stays low. When upstream stations outpace downstream, WIP piles up &mdash; matches sitting in bowls doing nothing.</li>
    <li class="m-purple"><span class="c-purple">Cumulative Overproduction</span> (purple filled area) &mdash; Each bowl has a max capacity of 4. When a station pushes matches into a bowl that's already full, the excess is wasted overproduction. This represents upstream stations working faster than their downstream neighbor can absorb.</li>
    <li class="m-red"><span class="c-red">Bottlenecks</span> &mdash; A bottleneck occurs when a bowl hits its max capacity (4) during a round. The stat shows how many bowls maxed out, and whether the bottleneck is <span class="c-orange">stable</span> (same stations each round) or <span class="c-red">moving</span> (shifting between stations &mdash; a sign of chaos in the system).</li>
    <li class="m-green"><span class="c-green">Per-Round Throughput</span> (bright green bars) &mdash; How many matches the last station delivered each round. Ranges 0&ndash;6, but you'll notice lots of low rolls due to starvation from upstream.</li>
    <li class="m-green"><span class="c-green">Flow Score</span> &mdash; A composite 0&ndash;100 score combining two factors:<br>
      &bull; <em>Throughput Efficiency</em> = actual throughput &divide; theoretical throughput<br>
      &bull; <em>Inventory Efficiency</em> = ideal WIP &divide; (ideal WIP + excess WIP)<br>
      Score = both multiplied together &times; 100. Green (&gt;80) is great, yellow (50&ndash;80) is struggling, red (&lt;50) means the line is badly degraded. More stations = lower score.</li>
  </ul>
</div>

<div class="controls">
  <button class="btn-roll" id="btnRoll" onclick="doRound()">Roll Dice</button>
  <button class="btn-auto" id="btnAuto" onclick="toggleAutoPlay()">Auto Play</button>
  <button class="btn-pause" id="btnPause" onclick="togglePause()" disabled>Pause</button>
  <div class="control-group">
    <label for="speedSlider">Speed:</label>
    <input type="range" id="speedSlider" min="1" max="10" value="5">
  </div>
  <div class="control-group">
    <label for="stationCount">Stations:</label>
    <select id="stationCount" onchange="changeStationCount()">
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5" selected>5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
    </select>
  </div>
  <button class="btn-reset" onclick="resetGame()">Reset</button>
</div>

<div class="production-line" id="productionLine"></div>

<div class="stats-rows">
  <div class="stats-panel">
    <div class="stat-card"><div class="stat-value blue" id="statRound">0</div><div class="stat-label">Round</div></div>
    <div class="stat-card"><div class="stat-value green" id="statFlowScore">-</div><div class="stat-label">Flow Score</div></div>
    <div class="stat-card"><div class="stat-value" id="statBottlenecks">0</div><div class="stat-label">Bottlenecks</div></div>
  </div>
  <div class="stats-panel">
    <div class="stat-card"><div class="stat-value green" id="statThroughput">0.0</div><div class="stat-label">Total Throughput</div></div>
    <div class="stat-card"><div class="stat-value blue" id="statTheoretical">0.0</div><div class="stat-label">Expected Throughput</div></div>
    <div class="stat-card"><div class="stat-value" id="statAvg">0.0</div><div class="stat-sub">expected 3.5</div><div class="stat-label">Avg Throughput / Round</div></div>
    <div class="stat-card"><div class="stat-value red" id="statWIP">0</div><div class="stat-label">WIP Inventory</div></div>
    <div class="stat-card"><div class="stat-value red" id="statLost">0</div><div class="stat-label">Lost Throughput</div></div>
    <div class="stat-card"><div class="stat-value purple" id="statOverprod">0</div><div class="stat-label">Overproduction</div></div>
  </div>
</div>

<div class="chart-container">
  <div class="chart-wrapper">
    <canvas id="chartCanvas"></canvas>
  </div>
</div>

<footer>
  Based on the dice game in <a href="https://en.wikipedia.org/wiki/The_Goal_(novel)" target="_blank">"The Goal"</a> by Eliyahu M. Goldratt (1984)
</footer>

<div class="animation-overlay" id="animOverlay"></div>

<script>
// ===== Station Names =====
const NAMES = ['Herbie','Davey','Ron','Chuck','Evan','Andy','Alex','Ben','Jake','Hank'];

// ===== Game State =====
let state = null;
let chart = null;
let autoPlaying = false;
let paused = false;
let animating = false;
let autoPlayTimer = null;

function createInitialState(numStations) {
  return {
    numStations,
    round: 0,
    inputBuffers: new Array(numStations).fill(0), // matches in bowl BEFORE each station
    diceValues: new Array(numStations).fill(0),
    moved: new Array(numStations).fill(0),
    starved: new Array(numStations).fill(false),
    totalThroughput: 0,
    history: [],        // per-round throughput
    cumulative: [],     // cumulative throughput after each round
    theoretical: [],    // cumulative theoretical (3.5 * round)
    wipHistory: [],           // total WIP snapshot after each round
    lostThroughput: 0,        // cumulative lost throughput (theoretical - actual)
    lostHistory: [],          // cumulative lost per round
    lostPerRound: [],         // lost this round (3.5 - actual)
    flowScoreHistory: [],     // flow score (0-100) after each round
    overproduction: 0,        // cumulative overproduction (buffer overflow)
    overproductionHistory: [], // cumulative overproduction per round
    overproductionPerRound: [], // overproduction this round only
    bottleneckHistory: [],     // number of full buffers per round
    bottleneckStations: [],    // which stations were bottlenecks last round
    bottleneckMoving: false,   // did bottleneck locations shift this round
    // Rolling window bottleneck detection (debounced)
    bufferHitHistory: new Array(numStations).fill(null).map(() => []),
    prevBufferHits: [],  // raw buffer-hit stations from last round (for debounce)
    currentBottleneck: -1,      // station index of THE bottleneck (-1 = none)
    bottleneckConsecutive: 0,   // how many consecutive rounds same station is THE bottleneck
    bottleneckRecentList: [],   // last 5 bottleneck station indices for "moving" display
  };
}

function rollDie() {
  return Math.floor(Math.random() * 6) + 1;
}

function executeRound() {
  state.round++;
  // Roll all dice
  for (let i = 0; i < state.numStations; i++) {
    state.diceValues[i] = rollDie();
  }
  // Process stations left to right
  const BUFFER_CAP = 4;
  let roundThroughput = 0;
  let roundOverproduction = 0;
  const roundBottleneckStations = [];
  for (let i = 0; i < state.numStations; i++) {
    const roll = state.diceValues[i];
    let available;
    if (i === 0) {
      available = roll; // unlimited raw materials
    } else {
      available = Math.min(roll, state.inputBuffers[i]);
    }
    state.moved[i] = available;
    state.starved[i] = (i > 0 && roll > state.inputBuffers[i]);

    // Remove from this station's input buffer
    if (i > 0) {
      state.inputBuffers[i] -= available;
    }
    // Add to next station's input buffer or throughput
    if (i < state.numStations - 1) {
      const newBuffer = state.inputBuffers[i + 1] + available;
      if (newBuffer >= BUFFER_CAP) {
        // Buffer hit capacity — this is a bottleneck
        roundBottleneckStations.push(i + 1);
        if (newBuffer > BUFFER_CAP) {
          roundOverproduction += newBuffer - BUFFER_CAP;
        }
        state.inputBuffers[i + 1] = BUFFER_CAP;
      } else {
        state.inputBuffers[i + 1] = newBuffer;
      }
    } else {
      roundThroughput = available;
    }
  }
  state.totalThroughput += roundThroughput;
  state.overproduction += roundOverproduction;
  state.history.push(roundThroughput);
  state.cumulative.push(state.totalThroughput);
  state.theoretical.push(3.5 * state.round);
  // Lost throughput = gap between theoretical and actual
  state.lostThroughput = 3.5 * state.round - state.totalThroughput;
  state.lostHistory.push(state.lostThroughput);
  state.lostPerRound.push(3.5 - roundThroughput);
  state.overproductionHistory.push(state.overproduction);
  state.overproductionPerRound.push(roundOverproduction);

  // Rolling window bottleneck detection (debounced)
  // Only count as real bottleneck if buffer also hit cap last round (sustained blockage)
  const debouncedStations = roundBottleneckStations.filter(s => state.prevBufferHits.includes(s));
  state.prevBufferHits = [...roundBottleneckStations]; // store raw hits for next round

  const WINDOW = 10;
  for (let i = 0; i < state.numStations; i++) {
    const hitCap = debouncedStations.includes(i);
    state.bufferHitHistory[i].push(hitCap);
    if (state.bufferHitHistory[i].length > WINDOW) state.bufferHitHistory[i].shift();
  }

  // Find station whose upstream buffer has highest hit frequency
  let maxFreq = 0;
  let maxStation = -1;
  for (let i = 1; i < state.numStations; i++) {
    const hist = state.bufferHitHistory[i];
    if (hist.length === 0) continue;
    const freq = hist.filter(Boolean).length / hist.length;
    if (freq > maxFreq) { maxFreq = freq; maxStation = i; }
  }
  if (maxFreq === 0) maxStation = -1;

  const prevBottleneck = state.currentBottleneck;
  if (maxStation === prevBottleneck && maxStation !== -1) {
    state.bottleneckConsecutive++;
  } else {
    state.bottleneckConsecutive = maxStation === -1 ? 0 : 1;
  }
  state.currentBottleneck = maxStation;

  // Track last 5 bottleneck stations for "moving" display
  if (maxStation !== -1) {
    state.bottleneckRecentList.push(maxStation);
    if (state.bottleneckRecentList.length > 5) state.bottleneckRecentList.shift();
  }

  // Determine stable vs moving
  const uniqueRecent = [...new Set(state.bottleneckRecentList)];
  state.bottleneckMoving = uniqueRecent.length > 1 && state.bottleneckConsecutive < 5;
  state.bottleneckStations = debouncedStations;
  state.bottleneckHistory.push(debouncedStations.length);

  // WIP snapshot
  const wip = state.inputBuffers.reduce((a, b) => a + b, 0);
  state.wipHistory.push(wip);

  // Flow Score
  const throughputEff = state.totalThroughput / (3.5 * state.round);
  const theoreticalWIP = state.numStations * 3.5;
  const excessWIP = Math.max(0, wip - theoreticalWIP);
  const inventoryEff = theoreticalWIP / (theoreticalWIP + excessWIP);
  const flowScore = Math.round(throughputEff * inventoryEff * 100);
  state.flowScoreHistory.push(flowScore);
}

// ===== DOM Building =====
function buildDOM() {
  const line = document.getElementById('productionLine');
  line.innerHTML = '';

  // Matchbox
  const mb = document.createElement('div');
  mb.className = 'matchbox';
  mb.innerHTML = `
    <div class="matchbox-label">Raw Materials</div>
    <div class="matchbox-body"><span class="matchbox-infinity">&infin;</span></div>
  `;
  line.appendChild(mb);

  // Arrow
  line.appendChild(makeArrow());

  // Stations
  for (let i = 0; i < state.numStations; i++) {
    const st = document.createElement('div');
    st.className = 'station';
    st.id = `station-${i}`;
    st.innerHTML = `
      <div class="station-name">${NAMES[i]}</div>
      <div class="die-container">
        <div class="die" id="die-${i}">
          ${[0,1,2,3,4,5,6,7,8].map(d => `<div class="dot" id="dot-${i}-${d}"></div>`).join('')}
        </div>
      </div>
      <div class="bowl-area" id="bowl-area-${i}">
        <svg class="bowl-svg" viewBox="0 0 80 55">
          <defs>
            <linearGradient id="bowlGrad-${i}" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#a07040"/>
              <stop offset="50%" stop-color="#c89060"/>
              <stop offset="100%" stop-color="#a07040"/>
            </linearGradient>
          </defs>
          <path d="M 5 10 Q 5 48, 40 48 Q 75 48, 75 10" fill="none" stroke="url(#bowlGrad-${i})" stroke-width="5" stroke-linecap="round"/>
          <path d="M 7 12 Q 7 46, 40 46 Q 73 46, 73 12" fill="rgba(15,31,58,0.7)" stroke="none"/>
          <path d="M 8 10 Q 8 10, 14 10" fill="none" stroke="rgba(255,220,160,0.3)" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        <div class="bowl-matches" id="bowl-matches-${i}"></div>
      </div>
      <div class="bowl-count" id="bowl-count-${i}">${i === 0 ? '' : '0'}</div>
      <div class="moved-info" id="moved-${i}"></div>
      <div class="inventory-bar-track"><div class="inventory-bar-fill" id="inv-bar-${i}" style="width:0%"></div></div>
    `;
    line.appendChild(st);

    if (i < state.numStations - 1) {
      line.appendChild(makeArrow());
    }
  }

  // Arrow to finished
  line.appendChild(makeArrow());

  // Finished goods tray
  const ft = document.createElement('div');
  ft.className = 'finished-tray';
  ft.innerHTML = `
    <div class="finished-label">Finished</div>
    <div class="finished-body" id="finishedBody"></div>
    <div class="finished-count" id="finishedCount">0</div>
  `;
  line.appendChild(ft);
}

function makeArrow() {
  const a = document.createElement('div');
  a.className = 'arrow';
  a.textContent = '\u25B6';
  return a;
}

// ===== Dice Face Rendering =====
// Dot visibility by face value. 3x3 grid indices: 0-8
const DICE_DOTS = {
  0: [],
  1: [4],
  2: [2, 6],
  3: [2, 4, 6],
  4: [0, 2, 6, 8],
  5: [0, 2, 4, 6, 8],
  6: [0, 2, 3, 5, 6, 8],
};

function renderDice() {
  for (let i = 0; i < state.numStations; i++) {
    const val = state.diceValues[i];
    const visible = DICE_DOTS[val] || [];
    for (let d = 0; d < 9; d++) {
      const dot = document.getElementById(`pot-${i}-${d}`) || document.getElementById(`dot-${i}-${d}`);
      if (dot) dot.classList.toggle('visible', visible.includes(d));
    }
    const die = document.getElementById(`die-${i}`);
    if (die) {
      die.classList.toggle('starved', state.starved[i]);
    }
  }
}

function renderBowls() {
  for (let i = 0; i < state.numStations; i++) {
    const count = state.inputBuffers[i];
    const countEl = document.getElementById(`bowl-count-${i}`);
    if (countEl) countEl.textContent = i === 0 ? '' : count;

    // Render mini matches in bowl (cap at 15 for visual)
    const matchesEl = document.getElementById(`bowl-matches-${i}`);
    if (matchesEl && i > 0) {
      const show = Math.min(count, 15);
      matchesEl.innerHTML = '';
      for (let m = 0; m < show; m++) {
        matchesEl.innerHTML += `<div class="bowl-match"><div class="head"></div><div class="stick"></div></div>`;
      }
    }

    // Inventory bar (relative to buffer cap of 6)
    const bar = document.getElementById(`inv-bar-${i}`);
    if (bar && i > 0) {
      const pct = Math.min(count / 6 * 100, 100);
      bar.style.width = pct + '%';
      bar.classList.toggle('full', count >= 6);
    }
  }
}

function renderMoved() {
  for (let i = 0; i < state.numStations; i++) {
    const el = document.getElementById(`moved-${i}`);
    if (el && state.round > 0) {
      const m = state.moved[i];
      const r = state.diceValues[i];
      if (state.starved[i]) {
        el.textContent = `Moved ${m}/${r}`;
        el.className = 'moved-info starved-text';
      } else {
        el.textContent = `Moved ${m}`;
        el.className = 'moved-info';
      }
    }
  }
}

function renderStats() {
  document.getElementById('statRound').textContent = state.round;
  document.getElementById('statThroughput').textContent = state.totalThroughput.toFixed(1);
  document.getElementById('statTheoretical').textContent = (3.5 * state.round).toFixed(1);
  const avgEl = document.getElementById('statAvg');
  if (state.round > 0) {
    const avg = state.totalThroughput / state.round;
    avgEl.textContent = avg.toFixed(1);
    avgEl.className = 'stat-value ' + (avg >= 3.2 ? 'green' : avg >= 2.5 ? 'yellow' : 'red');
  } else {
    avgEl.textContent = '0.0';
    avgEl.className = 'stat-value';
  }
  // WIP = sum of all input buffers
  const wip = state.inputBuffers.reduce((a, b) => a + b, 0);
  document.getElementById('statWIP').textContent = wip;
  // Lost throughput
  document.getElementById('statLost').textContent = state.lostThroughput;
  // Overproduction
  document.getElementById('statOverprod').textContent = state.overproduction;
  // Bottlenecks — rolling window detection
  const bnEl = document.getElementById('statBottlenecks');
  if (state.currentBottleneck === -1) {
    bnEl.textContent = 'None yet';
    bnEl.className = 'stat-value green';
  } else if (state.bottleneckMoving) {
    const recent = [...new Set(state.bottleneckRecentList)].map(s => NAMES[s]).join(',');
    bnEl.textContent = 'Moving (' + recent + ')';
    bnEl.className = 'stat-value red';
  } else {
    bnEl.textContent = NAMES[state.currentBottleneck] + (state.bottleneckConsecutive >= 5 ? '' : '');
    bnEl.className = 'stat-value orange';
  }
  // Apply bottleneck highlighting classes to stations
  for (let i = 0; i < state.numStations; i++) {
    const stEl = document.getElementById(`station-${i}`);
    if (!stEl) continue;
    stEl.classList.remove('bottleneck-stable', 'bottleneck-moving');
    if (i === state.currentBottleneck && state.currentBottleneck !== -1) {
      stEl.classList.add(state.bottleneckMoving ? 'bottleneck-moving' : 'bottleneck-stable');
    }
  }
  // Flow Score with color coding
  const flowEl = document.getElementById('statFlowScore');
  if (state.round > 0) {
    const score = state.flowScoreHistory[state.flowScoreHistory.length - 1];
    flowEl.textContent = score + '%';
    flowEl.className = 'stat-value ' + (score > 80 ? 'green' : score >= 50 ? 'yellow' : 'red');
  } else {
    flowEl.textContent = '-';
    flowEl.className = 'stat-value green';
  }
}

function renderFinished() {
  const body = document.getElementById('finishedBody');
  const countEl = document.getElementById('finishedCount');
  if (body) {
    const show = Math.min(state.totalThroughput, 80);
    body.innerHTML = '';
    for (let i = 0; i < show; i++) {
      body.innerHTML += `<div class="tiny-match"><div class="head"></div><div class="stick"></div></div>`;
    }
    // Glow effect when new throughput arrives
    if (state.history.length > 0 && state.history[state.history.length - 1] > 0) {
      body.classList.add('glow');
      setTimeout(() => body.classList.remove('glow'), 600);
    }
  }
  if (countEl) countEl.textContent = state.totalThroughput;
}

// ===== Chart =====
function initChart() {
  const ctx = document.getElementById('chartCanvas').getContext('2d');
  if (chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: [],
      datasets: [
        {
          label: 'Cumulative Actual',
          type: 'line',
          data: [],
          borderColor: '#30a060',
          backgroundColor: 'rgba(48,160,96,0.1)',
          fill: true,
          tension: 0.3,
          pointRadius: 2,
          pointBackgroundColor: '#30a060',
          yAxisID: 'y',
          order: 1,
        },
        {
          label: 'Expected Throughput',
          type: 'line',
          data: [],
          borderColor: '#f0c040',
          borderDash: [6, 3],
          backgroundColor: 'transparent',
          tension: 0,
          pointRadius: 0,
          yAxisID: 'y',
          order: 2,
        },
        {
          label: 'Cumulative Lost Throughput',
          type: 'line',
          data: [],
          borderColor: '#d04040',
          backgroundColor: 'rgba(208,64,64,0.15)',
          fill: true,
          tension: 0.3,
          pointRadius: 2,
          pointBackgroundColor: '#d04040',
          yAxisID: 'y',
          order: 3,
        },
        {
          label: 'WIP Inventory',
          type: 'line',
          data: [],
          borderColor: '#e08030',
          backgroundColor: 'rgba(224,128,48,0.12)',
          fill: true,
          tension: 0.3,
          pointRadius: 2,
          pointBackgroundColor: '#e08030',
          yAxisID: 'y2',
          order: 4,
        },
        {
          label: 'Cumulative Overproduction',
          type: 'line',
          data: [],
          borderColor: '#a060d0',
          backgroundColor: 'rgba(160,96,208,0.12)',
          fill: true,
          tension: 0.3,
          pointRadius: 2,
          pointBackgroundColor: '#a060d0',
          yAxisID: 'y',
          order: 5,
        },
        {
          label: 'Per-Round Throughput',
          type: 'bar',
          data: [],
          backgroundColor: 'rgba(80,230,120,0.35)',
          borderColor: 'rgba(80,230,120,0.7)',
          borderWidth: 1,
          yAxisID: 'y3',
          order: 6,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: 2.5,
      interaction: { intersect: false, mode: 'index' },
      plugins: {
        legend: {
          labels: { color: '#8aa8c8', font: { size: 11 } },
        },
        tooltip: {
          backgroundColor: '#0f1f3a',
          titleColor: '#e0e8f0',
          bodyColor: '#8aa8c8',
          borderColor: '#1a3050',
          borderWidth: 1,
          callbacks: {
            afterBody: function(items) {
              if (!items.length || !state.flowScoreHistory.length) return '';
              const idx = items[0].dataIndex;
              const lines = [];
              if (idx < state.flowScoreHistory.length) {
                lines.push('Flow Score: ' + state.flowScoreHistory[idx] + '%');
              }
              if (idx < state.overproductionPerRound.length && state.overproductionPerRound[idx] > 0) {
                lines.push('Overproduced this round: ' + state.overproductionPerRound[idx]);
              }
              if (idx < state.bottleneckHistory.length && state.bottleneckHistory[idx] > 0) {
                lines.push('Bottlenecks: ' + state.bottleneckHistory[idx]);
              }
              return lines.join('\n');
            }
          },
        },
      },
      scales: {
        x: {
          ticks: { color: '#4a6888', maxTicksLimit: 20, font: { size: 10 } },
          grid: { color: 'rgba(26,48,80,0.5)' },
          title: { display: true, text: 'Round', color: '#6088b0', font: { size: 11 } },
        },
        y: {
          position: 'left',
          ticks: { color: '#4a6888', font: { size: 10 } },
          grid: { color: 'rgba(26,48,80,0.5)' },
          title: { display: true, text: 'Cumulative', color: '#6088b0', font: { size: 11 } },
          beginAtZero: true,
        },
        y2: {
          position: 'right',
          ticks: { color: '#e08030', font: { size: 10 } },
          grid: { drawOnChartArea: false },
          title: { display: true, text: 'WIP Inventory', color: '#e08030', font: { size: 11 } },
          beginAtZero: true,
        },
        y3: {
          display: false,
          beginAtZero: true,
          max: 6,
        },
      },
    },
  });
}

function updateChart() {
  if (!chart) return;
  chart.data.labels = state.cumulative.map((_, i) => i + 1);
  chart.data.datasets[0].data = [...state.cumulative];
  chart.data.datasets[1].data = [...state.theoretical];
  chart.data.datasets[2].data = [...state.lostHistory];
  chart.data.datasets[3].data = [...state.wipHistory];
  chart.data.datasets[4].data = [...state.overproductionHistory];
  chart.data.datasets[5].data = [...state.history];
  chart.update('none');
}

// ===== Animations =====
function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

function getSpeed() {
  const v = parseInt(document.getElementById('speedSlider').value);
  // Speed 1 = slow (1500ms), 10 = fast (100ms)
  return 1600 - v * 150;
}

async function animateDiceRoll() {
  const duration = Math.min(getSpeed() * 0.35, 500);
  const dice = [];
  for (let i = 0; i < state.numStations; i++) {
    const die = document.getElementById(`die-${i}`);
    if (die) { die.classList.add('rolling'); dice.push(die); }
  }
  // Rapid cycling
  const steps = Math.max(4, Math.floor(duration / 60));
  for (let s = 0; s < steps; s++) {
    for (let i = 0; i < state.numStations; i++) {
      const fakeVal = Math.floor(Math.random() * 6) + 1;
      showDieFace(i, fakeVal);
    }
    await sleep(60);
  }
  // Show final values
  for (let i = 0; i < state.numStations; i++) {
    const die = document.getElementById(`die-${i}`);
    if (die) die.classList.remove('rolling');
    showDieFace(i, state.diceValues[i]);
  }
}

function showDieFace(station, value) {
  const visible = DICE_DOTS[value] || [];
  for (let d = 0; d < 9; d++) {
    const dot = document.getElementById(`dot-${station}-${d}`);
    if (dot) dot.classList.toggle('visible', visible.includes(d));
  }
}

async function animateFlyingMatches() {
  const overlay = document.getElementById('animOverlay');
  const baseDelay = Math.min(getSpeed() * 0.08, 80);

  for (let i = 0; i < state.numStations; i++) {
    const count = state.moved[i];
    if (count === 0) continue;

    // Get source and target positions
    let sourceEl, targetEl;
    if (i === 0) {
      sourceEl = document.querySelector('.matchbox-body');
    } else {
      sourceEl = document.getElementById(`bowl-area-${i}`);
    }
    if (i < state.numStations - 1) {
      targetEl = document.getElementById(`bowl-area-${i + 1}`);
    } else {
      targetEl = document.getElementById('finishedBody');
    }
    if (!sourceEl || !targetEl) continue;

    const srcRect = sourceEl.getBoundingClientRect();
    const tgtRect = targetEl.getBoundingClientRect();
    const sx = srcRect.left + srcRect.width / 2;
    const sy = srcRect.top + srcRect.height / 2;
    const tx = tgtRect.left + tgtRect.width / 2;
    const ty = tgtRect.top + tgtRect.height / 2;

    // Create flying matches
    const matches = [];
    for (let m = 0; m < Math.min(count, 6); m++) {
      const fm = document.createElement('div');
      fm.className = 'flying-match';
      fm.innerHTML = '<div class="head"></div><div class="stick"></div>';
      fm.style.left = (sx + (Math.random() - 0.5) * 10) + 'px';
      fm.style.top = (sy + (Math.random() - 0.5) * 10) + 'px';
      fm.style.opacity = '1';
      fm.style.transition = `left ${baseDelay * 4}ms ease-in-out, top ${baseDelay * 4}ms ease-in-out, opacity ${baseDelay * 2}ms ease`;
      overlay.appendChild(fm);
      matches.push(fm);
    }

    // Trigger flight
    await sleep(20);
    matches.forEach(fm => {
      fm.style.left = (tx + (Math.random() - 0.5) * 10) + 'px';
      fm.style.top = (ty + (Math.random() - 0.5) * 10) + 'px';
    });
    await sleep(baseDelay * 4);
    matches.forEach(fm => { fm.style.opacity = '0'; });
    await sleep(baseDelay * 2);
    matches.forEach(fm => fm.remove());
  }
}

// ===== Round Execution =====
async function doRound() {
  if (animating) return;
  animating = true;
  document.getElementById('btnRoll').disabled = true;

  // Execute the logic
  executeRound();

  // Animate dice
  await animateDiceRoll();
  renderDice();
  await sleep(Math.min(getSpeed() * 0.15, 200));

  // Animate flying matches
  await animateFlyingMatches();

  // Update all displays
  renderBowls();
  renderMoved();
  renderStats();
  renderFinished();
  updateChart();

  animating = false;
  if (!autoPlaying) {
    document.getElementById('btnRoll').disabled = false;
  }
}

// ===== Auto Play =====
async function toggleAutoPlay() {
  const btn = document.getElementById('btnAuto');
  const pauseBtn = document.getElementById('btnPause');
  if (autoPlaying) {
    autoPlaying = false;
    paused = false;
    btn.textContent = 'Auto Play';
    btn.classList.remove('playing');
    pauseBtn.textContent = 'Pause';
    pauseBtn.disabled = true;
    document.getElementById('btnRoll').disabled = false;
    return;
  }
  autoPlaying = true;
  paused = false;
  btn.textContent = 'Stop';
  btn.classList.add('playing');
  pauseBtn.textContent = 'Pause';
  pauseBtn.disabled = false;
  document.getElementById('btnRoll').disabled = true;

  while (autoPlaying) {
    if (paused) {
      await sleep(100);
      continue;
    }
    await doRound();
    if (!autoPlaying) break;
    const delay = Math.max(getSpeed() * 0.3, 50);
    await sleep(delay);
  }
}

function togglePause() {
  if (!autoPlaying) return;
  paused = !paused;
  const pauseBtn = document.getElementById('btnPause');
  pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  if (paused) {
    document.getElementById('btnRoll').disabled = false;
  } else {
    document.getElementById('btnRoll').disabled = true;
  }
}

// ===== Reset =====
function resetGame() {
  autoPlaying = false;
  paused = false;
  animating = false;
  const btn = document.getElementById('btnAuto');
  btn.textContent = 'Auto Play';
  btn.classList.remove('playing');
  document.getElementById('btnPause').textContent = 'Pause';
  document.getElementById('btnPause').disabled = true;
  document.getElementById('btnRoll').disabled = false;

  const n = parseInt(document.getElementById('stationCount').value);
  state = createInitialState(n);
  buildDOM();
  renderDice();
  renderBowls();
  renderStats();
  renderFinished();
  initChart();
}

function changeStationCount() {
  resetGame();
}

// ===== Toggle Rules =====
function toggleRules() {
  const box = document.getElementById('rulesBox');
  const btn = document.getElementById('rulesBtn');
  box.classList.toggle('open');
  btn.textContent = box.classList.contains('open') ? 'Hide Rules' : 'Show Rules';
}

// ===== Init =====
resetGame();
</script>

</body>
</html>
