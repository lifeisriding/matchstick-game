<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Matchstick Game - From "The Goal" by Eli Goldratt</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<style>
/* ===== Reset & Base ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: #0a1628;
  color: #e0e8f0;
  min-height: 100vh;
  overflow-x: hidden;
}

/* ===== Header ===== */
header {
  text-align: center;
  padding: 20px 20px 10px;
  background: linear-gradient(180deg, #0f1f3a 0%, #0a1628 100%);
  border-bottom: 1px solid #1a3050;
}
header h1 {
  font-size: 1.8rem;
  font-weight: 700;
  background: linear-gradient(135deg, #f0c040, #e8a020);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 4px;
}
header .subtitle {
  font-size: 0.85rem;
  color: #6088b0;
}

/* ===== Rules Toggle ===== */
.rules-toggle {
  text-align: center;
  margin: 8px 0;
}
.rules-toggle button {
  background: none;
  border: 1px solid #1a3050;
  color: #6088b0;
  padding: 4px 14px;
  border-radius: 12px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.2s;
}
.rules-toggle button:hover { border-color: #f0c040; color: #f0c040; }
.rules-box {
  display: none;
  max-width: 700px;
  margin: 10px auto;
  background: #0f1f3a;
  border: 1px solid #1a3050;
  border-radius: 10px;
  padding: 16px 20px;
  text-align: left;
  font-size: 0.82rem;
  line-height: 1.6;
  color: #8aa8c8;
}
.rules-box.open { display: block; }
.rules-box strong { color: #f0c040; }

/* ===== Controls ===== */
.controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  padding: 14px 20px;
  flex-wrap: wrap;
}
.controls button {
  padding: 8px 22px;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}
.btn-roll {
  background: linear-gradient(135deg, #f0c040, #e8a020);
  color: #1a1a2e;
}
.btn-roll:hover { transform: scale(1.05); box-shadow: 0 0 16px rgba(240,192,64,0.4); }
.btn-roll:disabled { opacity: 0.4; cursor: default; transform: none; box-shadow: none; }
.btn-auto {
  background: linear-gradient(135deg, #30a060, #208040);
  color: #fff;
}
.btn-auto.playing {
  background: linear-gradient(135deg, #d04040, #b03030);
}
.btn-auto:hover { transform: scale(1.05); }
.btn-reset {
  background: #1a3050;
  color: #8aa8c8;
  border: 1px solid #2a4060;
}
.btn-reset:hover { background: #2a4060; color: #e0e8f0; }
.control-group {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.82rem;
  color: #6088b0;
}
.control-group select, .control-group input[type="range"] {
  background: #1a3050;
  color: #e0e8f0;
  border: 1px solid #2a4060;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 0.82rem;
}
.control-group input[type="range"] {
  width: 80px;
  accent-color: #f0c040;
}

/* ===== Production Line ===== */
.production-line {
  display: flex;
  align-items: flex-start;
  justify-content: center;
  gap: 8px;
  padding: 20px 16px;
  overflow-x: auto;
  position: relative;
}

/* Arrow between stations */
.arrow {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.4rem;
  color: #2a4060;
  padding-top: 58px;
  min-width: 18px;
  flex-shrink: 0;
}

/* ===== Matchbox (raw materials) ===== */
.matchbox {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 80px;
  flex-shrink: 0;
}
.matchbox-label {
  font-size: 0.7rem;
  color: #6088b0;
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.matchbox-body {
  width: 70px;
  height: 90px;
  background: linear-gradient(145deg, #8b4513, #a0522d, #8b4513);
  border-radius: 6px;
  border: 2px solid #654321;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.3);
}
.matchbox-body::before {
  content: '';
  position: absolute;
  top: 4px; left: 4px; right: 4px; bottom: 4px;
  border: 1px solid rgba(255,200,100,0.15);
  border-radius: 3px;
}
.matchbox-infinity {
  font-size: 2.2rem;
  color: #f0c040;
  text-shadow: 0 0 10px rgba(240,192,64,0.5);
}

/* ===== Station ===== */
.station {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 90px;
  flex-shrink: 0;
  transition: all 0.3s;
}
.station-name {
  font-size: 0.75rem;
  font-weight: 600;
  color: #8aa8c8;
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ===== Die ===== */
.die-container {
  margin-bottom: 8px;
  perspective: 300px;
}
.die {
  width: 48px;
  height: 48px;
  background: #f5f0e8;
  border-radius: 10px;
  display: grid;
  grid-template-rows: repeat(3, 1fr);
  grid-template-columns: repeat(3, 1fr);
  padding: 6px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.8);
  transition: transform 0.1s, box-shadow 0.3s;
  position: relative;
}
.die.rolling {
  animation: diceRoll 0.08s infinite alternate;
}
@keyframes diceRoll {
  0% { transform: rotateX(-8deg) rotateY(8deg) scale(1.05); }
  100% { transform: rotateX(8deg) rotateY(-8deg) scale(1.05); }
}
.die.starved {
  box-shadow: 0 0 14px rgba(220,60,60,0.7), 0 3px 8px rgba(0,0,0,0.4);
}
.die .dot {
  width: 9px;
  height: 9px;
  background: #2a2a3a;
  border-radius: 50%;
  align-self: center;
  justify-self: center;
  opacity: 0;
  transition: opacity 0.15s;
}
.die .dot.visible { opacity: 1; }

/* Dot positions for dice faces */
/* Dots indexed 0-8 in 3x3 grid:
   0 1 2
   3 4 5
   6 7 8
*/

/* ===== Bowl (SVG inline) ===== */
.bowl-area {
  position: relative;
  width: 80px;
  height: 55px;
  margin-bottom: 4px;
}
.bowl-svg {
  width: 80px;
  height: 55px;
}
.bowl-matches {
  position: absolute;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 1px;
  justify-content: center;
  flex-wrap: wrap;
  max-width: 60px;
}
.bowl-match {
  width: 3px;
  height: 14px;
  position: relative;
}
.bowl-match .stick {
  width: 3px;
  height: 10px;
  background: linear-gradient(90deg, #c8a050, #dab060, #c8a050);
  position: absolute;
  bottom: 0;
  border-radius: 0 0 1px 1px;
}
.bowl-match .head {
  width: 5px;
  height: 5px;
  background: radial-gradient(circle at 40% 35%, #ff6040, #cc3020);
  border-radius: 50% 50% 30% 30%;
  position: absolute;
  top: 0;
  left: -1px;
}
.bowl-count {
  font-size: 0.95rem;
  font-weight: 700;
  color: #f0c040;
  min-height: 1.2em;
}
.moved-info {
  font-size: 0.7rem;
  color: #50a060;
  min-height: 1em;
  margin-top: 2px;
}
.moved-info.starved-text { color: #d04040; }

/* Inventory bar under bowl */
.inventory-bar-track {
  width: 60px;
  height: 4px;
  background: #1a3050;
  border-radius: 2px;
  margin-top: 4px;
  overflow: hidden;
}
.inventory-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #30a060, #f0c040);
  border-radius: 2px;
  transition: width 0.4s;
  min-width: 0;
}

/* ===== Finished Goods Tray ===== */
.finished-tray {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 90px;
  flex-shrink: 0;
}
.finished-label {
  font-size: 0.7rem;
  color: #6088b0;
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.finished-body {
  width: 80px;
  min-height: 90px;
  background: #0f1f3a;
  border: 2px solid #30a060;
  border-radius: 8px;
  display: flex;
  flex-wrap: wrap;
  align-content: flex-end;
  justify-content: center;
  gap: 1px;
  padding: 6px;
  box-shadow: 0 0 12px rgba(48,160,96,0.2);
  transition: box-shadow 0.3s;
}
.finished-body.glow {
  box-shadow: 0 0 20px rgba(48,160,96,0.5);
}
.finished-count {
  font-size: 1.1rem;
  font-weight: 700;
  color: #30a060;
  margin-top: 6px;
}

/* Small match icon in finished tray */
.tiny-match {
  width: 2px;
  height: 10px;
  position: relative;
}
.tiny-match .stick {
  width: 2px;
  height: 7px;
  background: linear-gradient(90deg, #c8a050, #dab060);
  position: absolute;
  bottom: 0;
}
.tiny-match .head {
  width: 4px;
  height: 4px;
  background: radial-gradient(circle at 40% 35%, #ff6040, #cc3020);
  border-radius: 50%;
  position: absolute;
  top: 0;
  left: -1px;
}

/* ===== Flying Match Animation Overlay ===== */
.animation-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 1000;
}
.flying-match {
  position: absolute;
  width: 4px;
  height: 18px;
  transition: none;
}
.flying-match .stick {
  width: 4px;
  height: 13px;
  background: linear-gradient(90deg, #c8a050, #dab060, #c8a050);
  position: absolute;
  bottom: 0;
  border-radius: 0 0 1px 1px;
}
.flying-match .head {
  width: 6px;
  height: 6px;
  background: radial-gradient(circle at 40% 35%, #ff6040, #cc3020);
  border-radius: 50% 50% 30% 30%;
  position: absolute;
  top: 0;
  left: -1px;
  box-shadow: 0 0 6px rgba(255,96,64,0.6);
}

/* ===== Stats Panel ===== */
.stats-panel {
  display: flex;
  justify-content: center;
  gap: 24px;
  padding: 16px 20px;
  flex-wrap: wrap;
}
.stat-card {
  text-align: center;
  background: #0f1f3a;
  border: 1px solid #1a3050;
  border-radius: 10px;
  padding: 10px 18px;
  min-width: 110px;
}
.stat-value {
  font-size: 1.4rem;
  font-weight: 700;
  color: #f0c040;
}
.stat-value.green { color: #30a060; }
.stat-value.red { color: #d04040; }
.stat-value.blue { color: #4090d0; }
.stat-label {
  font-size: 0.7rem;
  color: #6088b0;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 2px;
}

/* ===== Chart ===== */
.chart-container {
  max-width: 800px;
  margin: 10px auto 20px;
  padding: 0 20px;
}
.chart-wrapper {
  background: #0f1f3a;
  border: 1px solid #1a3050;
  border-radius: 12px;
  padding: 16px;
}

/* ===== Footer ===== */
footer {
  text-align: center;
  padding: 16px;
  font-size: 0.75rem;
  color: #3a5878;
  border-top: 1px solid #1a3050;
}
footer a { color: #6088b0; text-decoration: none; }
footer a:hover { color: #f0c040; }

/* ===== Responsive ===== */
@media (max-width: 768px) {
  header h1 { font-size: 1.3rem; }
  .production-line { gap: 4px; padding: 12px 8px; }
  .station { min-width: 60px; }
  .die { width: 36px; height: 36px; padding: 4px; }
  .die .dot { width: 7px; height: 7px; }
  .bowl-area { width: 60px; height: 42px; }
  .bowl-svg { width: 60px; height: 42px; }
  .arrow { font-size: 1rem; padding-top: 40px; }
  .stats-panel { gap: 10px; }
  .stat-card { min-width: 80px; padding: 8px 10px; }
  .stat-value { font-size: 1.1rem; }
  .controls { gap: 8px; }
  .controls button { padding: 6px 14px; font-size: 0.8rem; }
}
</style>
</head>
<body>

<header>
  <h1>The Matchstick Game</h1>
  <div class="subtitle">From "The Goal" by Eli Goldratt &mdash; Chapter 14</div>
</header>

<div class="rules-toggle">
  <button id="rulesBtn" onclick="toggleRules()">Show Rules</button>
</div>
<div class="rules-box" id="rulesBox">
  <strong>How it works:</strong> A line of workers (stations) passes matches from left to right. Each round, every worker rolls a die to determine how many matches they <em>can</em> move. But they can only move as many as are available in their bowl. Station 1 draws from unlimited raw materials.<br><br>
  <strong>The insight:</strong> With a single die (average 3.5), you'd expect ~3.5 matches/round of throughput. But because <strong>statistical fluctuations</strong> combine with <strong>dependent events</strong> (each station depends on the previous), actual throughput drops well below the average. Negative fluctuations propagate downstream; positive fluctuations are wasted when there aren't enough matches to move.<br><br>
  <strong>Controls:</strong> Click <strong>Roll</strong> to advance one round, or use <strong>Auto Play</strong> to run continuously. Adjust the number of stations (3-10) to see how line length affects throughput loss.
</div>

<div class="controls">
  <button class="btn-roll" id="btnRoll" onclick="doRound()">Roll Dice</button>
  <button class="btn-auto" id="btnAuto" onclick="toggleAutoPlay()">Auto Play</button>
  <div class="control-group">
    <label for="speedSlider">Speed:</label>
    <input type="range" id="speedSlider" min="1" max="10" value="5">
  </div>
  <div class="control-group">
    <label for="stationCount">Stations:</label>
    <select id="stationCount" onchange="changeStationCount()">
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5" selected>5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
    </select>
  </div>
  <button class="btn-reset" onclick="resetGame()">Reset</button>
</div>

<div class="production-line" id="productionLine"></div>

<div class="stats-panel" id="statsPanel">
  <div class="stat-card"><div class="stat-value blue" id="statRound">0</div><div class="stat-label">Round</div></div>
  <div class="stat-card"><div class="stat-value green" id="statThroughput">0</div><div class="stat-label">Total Throughput</div></div>
  <div class="stat-card"><div class="stat-value" id="statAvg">0.00</div><div class="stat-label">Avg / Round</div></div>
  <div class="stat-card"><div class="stat-value blue" id="statTheoretical">0.0</div><div class="stat-label">Theoretical</div></div>
  <div class="stat-card"><div class="stat-value red" id="statWIP">0</div><div class="stat-label">WIP Inventory</div></div>
</div>

<div class="chart-container">
  <div class="chart-wrapper">
    <canvas id="chartCanvas"></canvas>
  </div>
</div>

<footer>
  Based on the dice game in <a href="https://en.wikipedia.org/wiki/The_Goal_(novel)" target="_blank">"The Goal"</a> by Eliyahu M. Goldratt (1984)
</footer>

<div class="animation-overlay" id="animOverlay"></div>

<script>
// ===== Station Names =====
const NAMES = ['Andy','Ben','Chuck','Dave','Evan','Fran','Grace','Hank','Iris','Jake'];

// ===== Game State =====
let state = null;
let chart = null;
let autoPlaying = false;
let animating = false;
let autoPlayTimer = null;

function createInitialState(numStations) {
  return {
    numStations,
    round: 0,
    inputBuffers: new Array(numStations).fill(0), // matches in bowl BEFORE each station
    diceValues: new Array(numStations).fill(0),
    moved: new Array(numStations).fill(0),
    starved: new Array(numStations).fill(false),
    totalThroughput: 0,
    history: [],        // per-round throughput
    cumulative: [],     // cumulative throughput after each round
    theoretical: [],    // cumulative theoretical (3.5 * round)
  };
}

function rollDie() {
  return Math.floor(Math.random() * 6) + 1;
}

function executeRound() {
  state.round++;
  // Roll all dice
  for (let i = 0; i < state.numStations; i++) {
    state.diceValues[i] = rollDie();
  }
  // Process stations left to right
  let roundThroughput = 0;
  for (let i = 0; i < state.numStations; i++) {
    const roll = state.diceValues[i];
    let available;
    if (i === 0) {
      available = roll; // unlimited raw materials
    } else {
      available = Math.min(roll, state.inputBuffers[i]);
    }
    state.moved[i] = available;
    state.starved[i] = (i > 0 && roll > state.inputBuffers[i]);

    // Remove from this station's input buffer
    if (i > 0) {
      state.inputBuffers[i] -= available;
    }
    // Add to next station's input buffer or throughput
    if (i < state.numStations - 1) {
      state.inputBuffers[i + 1] += available;
    } else {
      roundThroughput = available;
    }
  }
  state.totalThroughput += roundThroughput;
  state.history.push(roundThroughput);
  state.cumulative.push(state.totalThroughput);
  state.theoretical.push(3.5 * state.round);
}

// ===== DOM Building =====
function buildDOM() {
  const line = document.getElementById('productionLine');
  line.innerHTML = '';

  // Matchbox
  const mb = document.createElement('div');
  mb.className = 'matchbox';
  mb.innerHTML = `
    <div class="matchbox-label">Raw Materials</div>
    <div class="matchbox-body"><span class="matchbox-infinity">&infin;</span></div>
  `;
  line.appendChild(mb);

  // Arrow
  line.appendChild(makeArrow());

  // Stations
  for (let i = 0; i < state.numStations; i++) {
    const st = document.createElement('div');
    st.className = 'station';
    st.id = `station-${i}`;
    st.innerHTML = `
      <div class="station-name">${NAMES[i]}</div>
      <div class="die-container">
        <div class="die" id="die-${i}">
          ${[0,1,2,3,4,5,6,7,8].map(d => `<div class="dot" id="dot-${i}-${d}"></div>`).join('')}
        </div>
      </div>
      <div class="bowl-area" id="bowl-area-${i}">
        <svg class="bowl-svg" viewBox="0 0 80 55">
          <defs>
            <linearGradient id="bowlGrad-${i}" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#a07040"/>
              <stop offset="50%" stop-color="#c89060"/>
              <stop offset="100%" stop-color="#a07040"/>
            </linearGradient>
          </defs>
          <path d="M 5 10 Q 5 48, 40 48 Q 75 48, 75 10" fill="none" stroke="url(#bowlGrad-${i})" stroke-width="5" stroke-linecap="round"/>
          <path d="M 7 12 Q 7 46, 40 46 Q 73 46, 73 12" fill="rgba(15,31,58,0.7)" stroke="none"/>
          <path d="M 8 10 Q 8 10, 14 10" fill="none" stroke="rgba(255,220,160,0.3)" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        <div class="bowl-matches" id="bowl-matches-${i}"></div>
      </div>
      <div class="bowl-count" id="bowl-count-${i}">${i === 0 ? '' : '0'}</div>
      <div class="moved-info" id="moved-${i}"></div>
      <div class="inventory-bar-track"><div class="inventory-bar-fill" id="inv-bar-${i}" style="width:0%"></div></div>
    `;
    line.appendChild(st);

    if (i < state.numStations - 1) {
      line.appendChild(makeArrow());
    }
  }

  // Arrow to finished
  line.appendChild(makeArrow());

  // Finished goods tray
  const ft = document.createElement('div');
  ft.className = 'finished-tray';
  ft.innerHTML = `
    <div class="finished-label">Finished</div>
    <div class="finished-body" id="finishedBody"></div>
    <div class="finished-count" id="finishedCount">0</div>
  `;
  line.appendChild(ft);
}

function makeArrow() {
  const a = document.createElement('div');
  a.className = 'arrow';
  a.textContent = '\u25B6';
  return a;
}

// ===== Dice Face Rendering =====
// Dot visibility by face value. 3x3 grid indices: 0-8
const DICE_DOTS = {
  0: [],
  1: [4],
  2: [2, 6],
  3: [2, 4, 6],
  4: [0, 2, 6, 8],
  5: [0, 2, 4, 6, 8],
  6: [0, 2, 3, 5, 6, 8],
};

function renderDice() {
  for (let i = 0; i < state.numStations; i++) {
    const val = state.diceValues[i];
    const visible = DICE_DOTS[val] || [];
    for (let d = 0; d < 9; d++) {
      const dot = document.getElementById(`pot-${i}-${d}`) || document.getElementById(`dot-${i}-${d}`);
      if (dot) dot.classList.toggle('visible', visible.includes(d));
    }
    const die = document.getElementById(`die-${i}`);
    if (die) {
      die.classList.toggle('starved', state.starved[i]);
    }
  }
}

function renderBowls() {
  for (let i = 0; i < state.numStations; i++) {
    const count = state.inputBuffers[i];
    const countEl = document.getElementById(`bowl-count-${i}`);
    if (countEl) countEl.textContent = i === 0 ? '' : count;

    // Render mini matches in bowl (cap at 15 for visual)
    const matchesEl = document.getElementById(`bowl-matches-${i}`);
    if (matchesEl && i > 0) {
      const show = Math.min(count, 15);
      matchesEl.innerHTML = '';
      for (let m = 0; m < show; m++) {
        matchesEl.innerHTML += `<div class="bowl-match"><div class="head"></div><div class="stick"></div></div>`;
      }
    }

    // Inventory bar (relative to max ~20)
    const bar = document.getElementById(`inv-bar-${i}`);
    if (bar && i > 0) {
      const pct = Math.min(count / 20 * 100, 100);
      bar.style.width = pct + '%';
    }
  }
}

function renderMoved() {
  for (let i = 0; i < state.numStations; i++) {
    const el = document.getElementById(`moved-${i}`);
    if (el && state.round > 0) {
      const m = state.moved[i];
      const r = state.diceValues[i];
      if (state.starved[i]) {
        el.textContent = `Moved ${m}/${r}`;
        el.className = 'moved-info starved-text';
      } else {
        el.textContent = `Moved ${m}`;
        el.className = 'moved-info';
      }
    }
  }
}

function renderStats() {
  document.getElementById('statRound').textContent = state.round;
  document.getElementById('statThroughput').textContent = state.totalThroughput;
  document.getElementById('statAvg').textContent = state.round > 0 ? (state.totalThroughput / state.round).toFixed(2) : '0.00';
  document.getElementById('statTheoretical').textContent = (3.5 * state.round).toFixed(1);
  // WIP = sum of all input buffers
  const wip = state.inputBuffers.reduce((a, b) => a + b, 0);
  document.getElementById('statWIP').textContent = wip;
}

function renderFinished() {
  const body = document.getElementById('finishedBody');
  const countEl = document.getElementById('finishedCount');
  if (body) {
    const show = Math.min(state.totalThroughput, 80);
    body.innerHTML = '';
    for (let i = 0; i < show; i++) {
      body.innerHTML += `<div class="tiny-match"><div class="head"></div><div class="stick"></div></div>`;
    }
    // Glow effect when new throughput arrives
    if (state.history.length > 0 && state.history[state.history.length - 1] > 0) {
      body.classList.add('glow');
      setTimeout(() => body.classList.remove('glow'), 600);
    }
  }
  if (countEl) countEl.textContent = state.totalThroughput;
}

// ===== Chart =====
function initChart() {
  const ctx = document.getElementById('chartCanvas').getContext('2d');
  if (chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: [],
      datasets: [
        {
          label: 'Cumulative Actual',
          type: 'line',
          data: [],
          borderColor: '#30a060',
          backgroundColor: 'rgba(48,160,96,0.1)',
          fill: true,
          tension: 0.3,
          pointRadius: 2,
          pointBackgroundColor: '#30a060',
          yAxisID: 'y',
          order: 1,
        },
        {
          label: 'Cumulative Theoretical',
          type: 'line',
          data: [],
          borderColor: '#f0c040',
          borderDash: [6, 3],
          backgroundColor: 'transparent',
          tension: 0,
          pointRadius: 0,
          yAxisID: 'y',
          order: 2,
        },
        {
          label: 'Per-Round Throughput',
          type: 'bar',
          data: [],
          backgroundColor: 'rgba(64,144,208,0.5)',
          borderColor: 'rgba(64,144,208,0.8)',
          borderWidth: 1,
          yAxisID: 'y2',
          order: 3,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: 2.5,
      interaction: { intersect: false, mode: 'index' },
      plugins: {
        legend: {
          labels: { color: '#8aa8c8', font: { size: 11 } },
        },
        tooltip: {
          backgroundColor: '#0f1f3a',
          titleColor: '#e0e8f0',
          bodyColor: '#8aa8c8',
          borderColor: '#1a3050',
          borderWidth: 1,
        },
      },
      scales: {
        x: {
          ticks: { color: '#4a6888', maxTicksLimit: 20, font: { size: 10 } },
          grid: { color: 'rgba(26,48,80,0.5)' },
          title: { display: true, text: 'Round', color: '#6088b0', font: { size: 11 } },
        },
        y: {
          position: 'left',
          ticks: { color: '#4a6888', font: { size: 10 } },
          grid: { color: 'rgba(26,48,80,0.5)' },
          title: { display: true, text: 'Cumulative', color: '#6088b0', font: { size: 11 } },
          beginAtZero: true,
        },
        y2: {
          position: 'right',
          ticks: { color: '#4a6888', font: { size: 10 }, stepSize: 1 },
          grid: { drawOnChartArea: false },
          title: { display: true, text: 'Per Round', color: '#6088b0', font: { size: 11 } },
          beginAtZero: true,
          max: 6,
        },
      },
    },
  });
}

function updateChart() {
  if (!chart) return;
  chart.data.labels = state.cumulative.map((_, i) => i + 1);
  chart.data.datasets[0].data = [...state.cumulative];
  chart.data.datasets[1].data = [...state.theoretical];
  chart.data.datasets[2].data = [...state.history];
  chart.update('none');
}

// ===== Animations =====
function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

function getSpeed() {
  const v = parseInt(document.getElementById('speedSlider').value);
  // Speed 1 = slow (1500ms), 10 = fast (100ms)
  return 1600 - v * 150;
}

async function animateDiceRoll() {
  const duration = Math.min(getSpeed() * 0.35, 500);
  const dice = [];
  for (let i = 0; i < state.numStations; i++) {
    const die = document.getElementById(`die-${i}`);
    if (die) { die.classList.add('rolling'); dice.push(die); }
  }
  // Rapid cycling
  const steps = Math.max(4, Math.floor(duration / 60));
  for (let s = 0; s < steps; s++) {
    for (let i = 0; i < state.numStations; i++) {
      const fakeVal = Math.floor(Math.random() * 6) + 1;
      showDieFace(i, fakeVal);
    }
    await sleep(60);
  }
  // Show final values
  for (let i = 0; i < state.numStations; i++) {
    const die = document.getElementById(`die-${i}`);
    if (die) die.classList.remove('rolling');
    showDieFace(i, state.diceValues[i]);
  }
}

function showDieFace(station, value) {
  const visible = DICE_DOTS[value] || [];
  for (let d = 0; d < 9; d++) {
    const dot = document.getElementById(`dot-${station}-${d}`);
    if (dot) dot.classList.toggle('visible', visible.includes(d));
  }
}

async function animateFlyingMatches() {
  const overlay = document.getElementById('animOverlay');
  const baseDelay = Math.min(getSpeed() * 0.08, 80);

  for (let i = 0; i < state.numStations; i++) {
    const count = state.moved[i];
    if (count === 0) continue;

    // Get source and target positions
    let sourceEl, targetEl;
    if (i === 0) {
      sourceEl = document.querySelector('.matchbox-body');
    } else {
      sourceEl = document.getElementById(`bowl-area-${i}`);
    }
    if (i < state.numStations - 1) {
      targetEl = document.getElementById(`bowl-area-${i + 1}`);
    } else {
      targetEl = document.getElementById('finishedBody');
    }
    if (!sourceEl || !targetEl) continue;

    const srcRect = sourceEl.getBoundingClientRect();
    const tgtRect = targetEl.getBoundingClientRect();
    const sx = srcRect.left + srcRect.width / 2;
    const sy = srcRect.top + srcRect.height / 2;
    const tx = tgtRect.left + tgtRect.width / 2;
    const ty = tgtRect.top + tgtRect.height / 2;

    // Create flying matches
    const matches = [];
    for (let m = 0; m < Math.min(count, 6); m++) {
      const fm = document.createElement('div');
      fm.className = 'flying-match';
      fm.innerHTML = '<div class="head"></div><div class="stick"></div>';
      fm.style.left = (sx + (Math.random() - 0.5) * 10) + 'px';
      fm.style.top = (sy + (Math.random() - 0.5) * 10) + 'px';
      fm.style.opacity = '1';
      fm.style.transition = `left ${baseDelay * 4}ms ease-in-out, top ${baseDelay * 4}ms ease-in-out, opacity ${baseDelay * 2}ms ease`;
      overlay.appendChild(fm);
      matches.push(fm);
    }

    // Trigger flight
    await sleep(20);
    matches.forEach(fm => {
      fm.style.left = (tx + (Math.random() - 0.5) * 10) + 'px';
      fm.style.top = (ty + (Math.random() - 0.5) * 10) + 'px';
    });
    await sleep(baseDelay * 4);
    matches.forEach(fm => { fm.style.opacity = '0'; });
    await sleep(baseDelay * 2);
    matches.forEach(fm => fm.remove());
  }
}

// ===== Round Execution =====
async function doRound() {
  if (animating) return;
  animating = true;
  document.getElementById('btnRoll').disabled = true;

  // Execute the logic
  executeRound();

  // Animate dice
  await animateDiceRoll();
  renderDice();
  await sleep(Math.min(getSpeed() * 0.15, 200));

  // Animate flying matches
  await animateFlyingMatches();

  // Update all displays
  renderBowls();
  renderMoved();
  renderStats();
  renderFinished();
  updateChart();

  animating = false;
  if (!autoPlaying) {
    document.getElementById('btnRoll').disabled = false;
  }
}

// ===== Auto Play =====
async function toggleAutoPlay() {
  const btn = document.getElementById('btnAuto');
  if (autoPlaying) {
    autoPlaying = false;
    btn.textContent = 'Auto Play';
    btn.classList.remove('playing');
    document.getElementById('btnRoll').disabled = false;
    return;
  }
  autoPlaying = true;
  btn.textContent = 'Stop';
  btn.classList.add('playing');
  document.getElementById('btnRoll').disabled = true;

  while (autoPlaying) {
    await doRound();
    if (!autoPlaying) break;
    const pause = Math.max(getSpeed() * 0.3, 50);
    await sleep(pause);
  }
}

// ===== Reset =====
function resetGame() {
  autoPlaying = false;
  animating = false;
  const btn = document.getElementById('btnAuto');
  btn.textContent = 'Auto Play';
  btn.classList.remove('playing');
  document.getElementById('btnRoll').disabled = false;

  const n = parseInt(document.getElementById('stationCount').value);
  state = createInitialState(n);
  buildDOM();
  renderDice();
  renderBowls();
  renderStats();
  renderFinished();
  initChart();
}

function changeStationCount() {
  resetGame();
}

// ===== Toggle Rules =====
function toggleRules() {
  const box = document.getElementById('rulesBox');
  const btn = document.getElementById('rulesBtn');
  box.classList.toggle('open');
  btn.textContent = box.classList.contains('open') ? 'Hide Rules' : 'Show Rules';
}

// ===== Init =====
resetGame();
</script>

</body>
</html>
